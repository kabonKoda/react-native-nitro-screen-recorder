package com.margelo.nitro.nitroscreenrecorder

import android.app.*
import android.content.Context
import android.content.Intent
import android.graphics.Bitmap
import android.graphics.PixelFormat
import android.hardware.display.DisplayManager
import android.hardware.display.VirtualDisplay
import android.media.Image
import android.media.ImageReader
import android.media.projection.MediaProjection
import android.media.projection.MediaProjectionManager
import android.os.Binder
import android.os.Handler
import android.os.HandlerThread
import android.os.IBinder
import android.util.Log
import androidx.core.app.NotificationCompat
import com.margelo.nitro.nitroscreenrecorder.utils.RecorderUtils
import java.nio.ByteBuffer

class ScreenStreamingService : Service() {

  private var mediaProjection: MediaProjection? = null
  private var virtualDisplay: VirtualDisplay? = null
  private var imageReader: ImageReader? = null
  private var isStreaming = false

  private var screenWidth = 0
  private var screenHeight = 0
  private var screenDensity = 0
  private var startId: Int = -1

  private var handlerThread: HandlerThread? = null
  private var handler: Handler? = null

  private val binder = LocalBinder()

  private val mediaProjectionCallback = object : MediaProjection.Callback() {
    override fun onStop() {
      Log.d(TAG, "üì± MediaProjection stopped")
      if (isStreaming) {
        stopStreaming()
      }
    }
  }

  companion object {
    private const val TAG = "ScreenStreamingService"
    private const val NOTIFICATION_ID = 1001
    private const val CHANNEL_ID = "screen_streaming_channel"
    const val ACTION_START_STREAMING = "START_STREAMING"
    const val ACTION_STOP_STREAMING = "STOP_STREAMING"
    const val EXTRA_RESULT_CODE = "RESULT_CODE"
    const val EXTRA_RESULT_DATA = "RESULT_DATA"
    const val EXTRA_FPS = "FPS"
    const val EXTRA_SCALE = "SCALE"
  }

  inner class LocalBinder : Binder() {
    fun getService(): ScreenStreamingService = this@ScreenStreamingService
  }

  override fun onCreate() {
    super.onCreate()
    Log.d(TAG, "üöÄ ScreenStreamingService onCreate called")
    RecorderUtils.createNotificationChannel(
      this,
      CHANNEL_ID,
      "Screen Streaming",
      "Screen streaming notification"
    )
    val metrics = RecorderUtils.initializeScreenMetrics(this)
    screenWidth = metrics.width
    screenHeight = metrics.height
    screenDensity = metrics.density

    // Create background thread for frame processing
    handlerThread = HandlerThread("FrameProcessingThread").apply {
      start()
      handler = Handler(looper)
    }

    Log.d(TAG, "‚úÖ ScreenStreamingService created successfully")
  }

  override fun onBind(intent: Intent?): IBinder {
    Log.d(TAG, "üîó onBind called")
    return binder
  }

  override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
    Log.d(TAG, "üöÄ onStartCommand called with action: ${intent?.action}")

    this.startId = startId

    when (intent?.action) {
      ACTION_START_STREAMING -> {
        val resultCode = intent.getIntExtra(EXTRA_RESULT_CODE, Activity.RESULT_CANCELED)
        val resultData = intent.getParcelableExtra<Intent>(EXTRA_RESULT_DATA)
        val fps = intent.getIntExtra(EXTRA_FPS, 30)
        val scale = intent.getFloatExtra(EXTRA_SCALE, 1.0f)

        Log.d(TAG, "üé¨ Start streaming: resultCode=$resultCode, fps=$fps, scale=$scale")

        if (resultData != null) {
          startStreaming(resultCode, resultData, fps, scale)
        } else {
          Log.e(TAG, "‚ùå ResultData is null, cannot start streaming")
        }
      }
      ACTION_STOP_STREAMING -> {
        Log.d(TAG, "üõë Stop streaming action received")
        stopStreaming()
      }
    }

    return START_NOT_STICKY
  }

  private fun createForegroundNotification(isStreaming: Boolean): Notification {
    Log.d(TAG, "üîî Creating foreground notification: isStreaming=$isStreaming")

    val stopIntent = Intent(this, ScreenStreamingService::class.java).apply {
      action = ACTION_STOP_STREAMING
    }
    val stopPendingIntent = PendingIntent.getService(
      this,
      0,
      stopIntent,
      PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
    )

    return NotificationCompat.Builder(this, CHANNEL_ID)
      .setContentTitle(if (isStreaming) "Streaming screen..." else "Screen streaming")
      .setContentText(if (isStreaming) "Tap to stop streaming" else "Preparing to stream")
      .setSmallIcon(android.R.drawable.ic_media_play)
      .setOngoing(true)
      .setPriority(NotificationCompat.PRIORITY_LOW)
      .apply {
        if (isStreaming) {
          addAction(android.R.drawable.ic_media_pause, "Stop", stopPendingIntent)
        }
      }
      .build()
  }

  fun startStreaming(
    resultCode: Int,
    resultData: Intent,
    fps: Int = 30,
    scale: Float = 1.0f
  ) {
    Log.d(TAG, "üé¨ startStreaming called: resultCode=$resultCode, fps=$fps, scale=$scale")

    if (isStreaming) {
      Log.w(TAG, "‚ö†Ô∏è Already streaming")
      return
    }

    try {
      startForeground(NOTIFICATION_ID, createForegroundNotification(false))

      val mediaProjectionManager =
        getSystemService(Context.MEDIA_PROJECTION_SERVICE) as MediaProjectionManager
      mediaProjection = mediaProjectionManager.getMediaProjection(resultCode, resultData)

      // Register the callback
      mediaProjection?.registerCallback(mediaProjectionCallback, null)

      // Calculate scaled dimensions
      val scaledWidth = (screenWidth * scale).toInt()
      val scaledHeight = (screenHeight * scale).toInt()

      // Create ImageReader to capture frames
      imageReader = ImageReader.newInstance(
        scaledWidth,
        scaledHeight,
        PixelFormat.RGBA_8888,
        2 // Max number of images
      )

      // Set frame available listener
      imageReader?.setOnImageAvailableListener({ reader ->
        processFrame(reader)
      }, handler)

      // Create virtual display
      virtualDisplay = mediaProjection?.createVirtualDisplay(
        "ScreenStreamingDisplay",
        scaledWidth,
        scaledHeight,
        screenDensity,
        DisplayManager.VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR,
        imageReader?.surface,
        null,
        null
      )

      isStreaming = true

      val notificationManager = getSystemService(NotificationManager::class.java)
      notificationManager.notify(NOTIFICATION_ID, createForegroundNotification(true))

      val event = ScreenRecordingEvent(
        type = RecordingEventType.GLOBAL,
        reason = RecordingEventReason.BEGAN
      )
      NitroScreenRecorder.notifyGlobalRecordingEvent(event)

      Log.d(TAG, "üéâ Screen streaming started successfully")

    } catch (e: Exception) {
      Log.e(TAG, "‚ùå Error starting streaming: ${e.message}")
      e.printStackTrace()
      val error = RecordingError(
        name = "StreamingStartError",
        message = e.message ?: "Failed to start streaming"
      )
      NitroScreenRecorder.notifyGlobalRecordingError(error)
      cleanup()
      stopSelf(this.startId)
    }
  }

  private fun processFrame(reader: ImageReader) {
    var image: Image? = null
    try {
      image = reader.acquireLatestImage()
      if (image != null) {
        // Convert Image to ByteArray or Bitmap
        val bitmap = imageToBitmap(image)
        
        // Notify listeners with the frame
        NitroScreenRecorder.notifyFrameAvailable(bitmap)
        
        // Or if you prefer raw bytes:
        // val bytes = imageToByteArray(image)
        // NitroScreenRecorder.notifyFrameBytes(bytes, image.width, image.height)
      }
    } catch (e: Exception) {
      Log.e(TAG, "‚ùå Error processing frame: ${e.message}")
    } finally {
      image?.close()
    }
  }

  private fun imageToBitmap(image: Image): Bitmap {
    val planes = image.planes
    val buffer: ByteBuffer = planes[0].buffer
    val pixelStride = planes[0].pixelStride
    val rowStride = planes[0].rowStride
    val rowPadding = rowStride - pixelStride * image.width

    val bitmap = Bitmap.createBitmap(
      image.width + rowPadding / pixelStride,
      image.height,
      Bitmap.Config.ARGB_8888
    )
    bitmap.copyPixelsFromBuffer(buffer)

    // Crop if there's padding
    return if (rowPadding != 0) {
      Bitmap.createBitmap(bitmap, 0, 0, image.width, image.height)
    } else {
      bitmap
    }
  }

  private fun imageToByteArray(image: Image): ByteArray {
    val planes = image.planes
    val buffer: ByteBuffer = planes[0].buffer
    val bytes = ByteArray(buffer.remaining())
    buffer.get(bytes)
    return bytes
  }

  fun stopStreaming() {
    Log.d(TAG, "üõë stopStreaming called")

    if (!isStreaming) {
      Log.w(TAG, "‚ö†Ô∏è Not streaming")
      return
    }

    try {
      isStreaming = false

      val event = ScreenRecordingEvent(
        type = RecordingEventType.GLOBAL,
        reason = RecordingEventReason.ENDED
      )
      NitroScreenRecorder.notifyGlobalRecordingEvent(event)

      Log.d(TAG, "üéâ Screen streaming stopped successfully")

    } catch (e: Exception) {
      Log.e(TAG, "‚ùå Error stopping streaming: ${e.message}")
      e.printStackTrace()
      val error = RecordingError(
        name = "StreamingStopError",
        message = e.message ?: "Failed to stop streaming"
      )
      NitroScreenRecorder.notifyGlobalRecordingError(error)
    } finally {
      cleanup()
      stopForeground(true)
      stopSelf(this.startId)
    }
  }

  private fun cleanup() {
    Log.d(TAG, "üßπ cleanup() called")

    try {
      virtualDisplay?.release()
      virtualDisplay = null

      imageReader?.close()
      imageReader = null

      // Unregister callback before stopping MediaProjection
      mediaProjection?.unregisterCallback(mediaProjectionCallback)
      mediaProjection?.stop()
      mediaProjection = null

      Log.d(TAG, "‚úÖ Cleanup completed")
    } catch (e: Exception) {
      Log.e(TAG, "‚ùå Error during cleanup: ${e.message}")
    }
  }

  fun isCurrentlyStreaming(): Boolean = isStreaming

  override fun onDestroy() {
    Log.d(TAG, "üíÄ onDestroy called")
    cleanup()
    handlerThread?.quitSafely()
    handlerThread = null
    handler = null
    super.onDestroy()
  }
}
